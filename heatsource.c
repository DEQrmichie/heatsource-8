/* Generated by py2cmod
 *
 * py2cmod (c) 2001 Mark Rowe
 */

#include "Python.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

struct MacCormickStruct
{
	double Value[2];
};
struct MuskingumStruct
{
	double Value[3];
};
struct GeometryStruct
{
	double Value[7];
};
struct SolarStruct
{
	double Value[8];
};
struct GroundStruct
{
	double Value[9];
};

static PyObject *HeatSourceError;

static char heatsource_CalcSolarPosition__doc__[] =
"Calculates relative position of sun"
;

static PyObject *
heatsource_CalcSolarPosition(PyObject *self, PyObject *args, PyObject *kwargs)
{
	double lat = PyFloat_AsDouble(PyTuple_GetItem(args,0));
	double lon = PyFloat_AsDouble(PyTuple_GetItem(args,1));
	long hour = PyInt_AsLong(PyTuple_GetItem(args,2));
	long min = PyInt_AsLong(PyTuple_GetItem(args,3));
	long sec = PyInt_AsLong(PyTuple_GetItem(args,4));
	long offset = PyInt_AsLong(PyTuple_GetItem(args,5));
	double JDC = PyFloat_AsDouble(PyTuple_GetItem(args,6));

	double Dummy,Dummy1,Dummy2,Dummy3,Dummy4,Dummy5;
	// temporary values calculated
	double MeanObliquity; // Average obliquity (degrees)
	double Obliquity; // Corrected obliquity (degrees)
    double Eccentricity; // Eccentricity of earth's orbit (unitless)
    double GeoMeanLongSun; //Geometric mean of the longitude of the sun
	double GeoMeanAnomalySun; // Geometric mean of anomaly of the sun
    double SunEqofCenter; // Equation of the center of the sun (degrees)
    double SunApparentLong; //Apparent longitude of the sun (degrees)
    double Declination; //Solar declination (degrees)
	double SunRadVector; //    #Distance to the sun in AU
	double Et; // Equation of time (minutes)
	double SolarTime; //Solar Time (minutes)
	double HourAngle;
	double Zenith; //Solar Zenith Corrected for Refraction (degrees)
	double Azimuth; // Solar azimuth in degrees
	double Altitude; //Solar Altitude Corrected for Refraction (degrees)
	double RefractionCorrection;
	double AtmElevation;
	double pi = 3.1415926535897931;
	double toRadians = pi/180.0;
	double toDegrees = 180.0/pi;

    MeanObliquity = 23.0 + (26.0 + ((21.448 - JDC * (46.815 + JDC * (0.00059 - JDC * 0.001813))) / 60.0)) / 60.0;
    Obliquity = MeanObliquity + 0.00256 * cos(toRadians*(125.04 - 1934.136 * JDC));
    Eccentricity = 0.016708634 - JDC * (0.000042037 + 0.0000001267 * JDC);
    GeoMeanLongSun = 280.46646 + JDC * (36000.76983 + 0.0003032 * JDC);

    while (GeoMeanLongSun < 0) { GeoMeanLongSun += 360; }
   	while (GeoMeanLongSun > 360) { GeoMeanLongSun -= 360; }
    GeoMeanAnomalySun = 357.52911 + JDC * (35999.05029 - 0.0001537 * JDC);

    Dummy1 = toRadians*(GeoMeanAnomalySun);
    Dummy2 = sin(Dummy1);
    Dummy3 = sin(Dummy2 * 2);
    Dummy4 = sin(Dummy3 * 3);
    SunEqofCenter = Dummy2 * (1.914602 - JDC * (0.004817 + 0.000014 * JDC)) + Dummy3 * (0.019993 - 0.000101 * JDC) + Dummy4 * 0.000289;
    SunApparentLong = (GeoMeanLongSun + SunEqofCenter) - 0.00569 - 0.00478 * sin(toRadians*((125.04 - 1934.136 * JDC)));

    Dummy1 = sin(toRadians*Obliquity) * sin(toRadians*SunApparentLong);
    Declination = toDegrees*(atan(Dummy1 / sqrt(-Dummy1 * Dummy1 + 1)));

    SunRadVector = (1.000001018 * (1 - pow(Eccentricity,2))) / (1 + Eccentricity * cos(toRadians*(GeoMeanAnomalySun + SunEqofCenter)));

    //======================================================
    //Equation of time (minutes)
    Dummy = pow((tan(Obliquity * pi / 360)),2);
    Dummy1 = sin(toRadians*(2 * GeoMeanLongSun));
    Dummy2 = sin(toRadians*(GeoMeanAnomalySun));
    Dummy3 = cos(toRadians*(2 * GeoMeanLongSun));
    Dummy4 = sin(toRadians*(4 * GeoMeanLongSun));
    Dummy5 = sin(toRadians*(2 * GeoMeanAnomalySun));
    Et = toDegrees*(4 * (Dummy * Dummy1 - 2 * Eccentricity * Dummy2 + 4 * Eccentricity * Dummy * Dummy2 * Dummy3 - 0.5 * pow(Dummy,2) * Dummy4 - 1.25 * pow(Eccentricity,2) * Dummy5));

    SolarTime = (hour*60.0) + min + (sec/60.0) + (Et - 4.0 * -lon + (offset*60.0));

    while (SolarTime > 1440.0) { SolarTime -= 1440.0;}
    HourAngle = SolarTime / 4.0 - 180.0;
    if (HourAngle < -180.0) { HourAngle += 360.0;}

    Dummy = sin(toRadians*lat) * sin(toRadians*Declination) + cos(toRadians*lat) * cos(toRadians*Declination) * cos(toRadians*HourAngle);
    if (Dummy > 1.0) { Dummy = 1.0; }
    else if (Dummy < -1.0) { Dummy = -1.0; }

    Zenith = toDegrees*(acos(Dummy));
    Dummy = cos(toRadians*lat) * sin(toRadians*Zenith);
    if (fabs(Dummy) >= 0.000999f)
    {
        Azimuth = (sin(toRadians*lat) * cos(toRadians*Zenith) - sin(toRadians*Declination)) / Dummy;
        if (fabs(Azimuth) > 1.0)
        {
            if (Azimuth < 0) { Azimuth = -1.0; }
            else { Azimuth = 1.0; }
        }

        Azimuth = 180 - toDegrees*(acos(Azimuth));
        if (HourAngle > 0) { Azimuth *= -1.0; }
    } else
    {
        if (lat > 0) { Azimuth = 180.0; }
        else { Azimuth = 0.0; }
    }
    if (Azimuth < 0) { Azimuth += 360.0; }

    AtmElevation = 90 - Zenith;
    if (AtmElevation > 85) { RefractionCorrection = 0;}
    else
    {
        Dummy = tan(toRadians*(AtmElevation));
        if (AtmElevation > 5) {RefractionCorrection = 58.1 / Dummy - 0.07 / pow(Dummy,3) + 0.000086 / pow(Dummy,5); }
        else if (AtmElevation > -0.575) { RefractionCorrection = 1735 + AtmElevation * (-518.2 + AtmElevation * (103.4 + AtmElevation * (-12.79 + AtmElevation * 0.711)));}
        else { RefractionCorrection = -20.774 / Dummy; }
        RefractionCorrection = RefractionCorrection / 3600;
    }
    Zenith = Zenith - RefractionCorrection;
    Altitude = 90 - Zenith;
	int Daytime = 0;
	if (Altitude > 0.0)
	{
		Daytime = 1;
	}

	/* Implementation of a bisect routine, inlined for speed. Look at the Python bisect code for details */
	float AzimuthBreaks[] = {0.0,67.5,112.5,157.5,202.5,247.5,292.5};
	int lo = 0;
	int hi = 7;
	int mid;
	float *litem;

	while (lo < hi) {
		mid = (lo + hi) / 2;
		litem = &AzimuthBreaks[mid];
		if (&litem == NULL)
		  	PyErr_SetString(HeatSourceError, "Bad value in SetSolarPosition's bisect routine (WTF? Better call for help.)");
		if ( Azimuth < *litem) { hi = mid;}
		else if (Azimuth >= *litem) {lo = mid + 1;}
		else {PyErr_SetString(HeatSourceError, "Bad value in SetSolarPosition's bisect routine (WTF? Better call for help.)");}

	}
	lo -= 1;

	return Py_BuildValue("ddii",Altitude,Zenith,Daytime,lo);
}

struct GeometryStruct
GetStreamGeometry(float Q_est, float W_b, float z, float n, float S, float D_est, float dx, float dt)
{
    double Converge = 10.0;
    double dy = 0.01;
    int count = 0;
	double Fy;
	double Fyy;
	double dFy;
	double thed;
	double power = 2.0/3.0;
	if (D_est == 0.0)
	{
	    while (Converge > 1e-6)
		{
	        Fy = (D_est * (W_b + z * D_est)) * pow(((D_est * (W_b + z * D_est)) / (W_b + 2 * D_est * sqrt(1+ pow(z,2)))),power) - ((n * Q_est) / sqrt(S));
	        thed = D_est + dy;
	        Fyy = (thed * (W_b + z * thed)) * pow((thed * (W_b + z * thed))/ (W_b + 2 * thed * sqrt(1+ pow(z,2))),power) - (n * Q_est) / sqrt(S);
	        dFy = (Fyy - Fy) / dy;
	        if (dFy <= 0) {dFy = 0.99;}
	        D_est -= Fy / dFy;
	        if ((D_est < 0) || (D_est > 5000) || (count > 10000))
	        {
	        	D_est = (double)rand();
	        	Converge = 0;
	        	count = 0;
	        }
	        Converge = fabs(Fy/dFy);
	        count += 1;
		}
	}
	double A = (D_est * (W_b + z * D_est));
	double Pw = (W_b + 2 * D_est * sqrt(1+ pow(z,2)));
	double Rh = A/Pw;
	double Ww = W_b + 2 * z * D_est;
	double U = Q_est / A;
	double Dispersion, Shear_Velocity;
    if (S == 0.0) {
        Shear_Velocity = U;
    } else {
        Shear_Velocity = sqrt(9.8 * D_est * S);
    }
    Dispersion = (0.011 * pow(U,2.0) * pow(Ww,2.0)) / (D_est * Shear_Velocity);
    if ((Dispersion * dt / pow(dx,2.0)) > 0.5)
       Dispersion = (0.45 * pow(dx,2)) / dt;

	struct GeometryStruct result;
	result.Value[0] = D_est;
	result.Value[1] = A;
	result.Value[2] = Pw;
	result.Value[3] = Rh;
	result.Value[4] = Ww;
	result.Value[5] = U;
	result.Value[6] = Dispersion;
	return result;
}

struct MuskingumStruct CalcMuskingum(float Q_est, float U, float W_w, float S, float dx, float dt)
{
    float c_k = (5.0/3.0) * U;  // Wave celerity
    float X = 0.5 * (1.0 - Q_est / (W_w * S * dx * c_k));
    if (X > 0.5) { X = 0.5; }
    else if (X < 0.0) {	X = 0.0; }
    float K = dx / c_k;

    // Check the celerity to ensure stability. These tests are from the VB code.
    if (dt >= (2 * K * (1 - X)))
		{
			PyObject *msg = PyString_FromString("Unstable celerity. Decrease dt or increase dx");
			PyErr_SetObject(HeatSourceError, Py_BuildValue("(Offfff)", msg, dt, dx, K, X, c_k));
		}
    // These calculations are from Chow's "Applied Hydrology"
    float D = K * (1 - X) + 0.5 * dt;
    float C1 = (0.5*dt - K * X) / D;
    float C2 = (0.5*dt + K * X) / D;
    float C3 = (K * (1 - X) - 0.5*dt) / D;
    // TODO: reformulate this using an updated model, such as Moramarco, et.al., 2006
	struct MuskingumStruct result;
	result.Value[0] = C1;
	result.Value[1] = C2;
	result.Value[2] = C3;
    return result;
}

static char heatsource_CalcFlows__doc__[] =
"Calculate all of the flows"
;

static PyObject * heatsource_CalcFlows(PyObject *self, PyObject *args)
{
	double U, W_w, S, dx, dt, W_b, z, n, D_est;
	double inputs, Q_up_prev, Q_up, Q, Q_bc;
	if (!PyArg_ParseTuple(args, "dddddddddddddd", &U, &W_w, &W_b, &S, &dx, &dt, &z, &n, &D_est,
											  	  &Q, &Q_up, &Q_up_prev, &inputs, &Q_bc))
		return NULL;

	struct GeometryStruct Geom;
	double Q_new;
	if (Q_bc >= 0)
	{
		Q_new = Q_bc;
	} else {
		double Q1 = Q_up + inputs;
		double Q2 = Q_up_prev + inputs;
		struct MuskingumStruct C = CalcMuskingum(Q2, U, W_w, S, dx, dt);
		Q_new = C.Value[0]*Q1 + C.Value[1]*Q2 + C.Value[2]*Q;
	}
	if (Q_new > 0.0071)
	{
		Geom = GetStreamGeometry(Q_new, W_b, z, n, S, D_est, dx, dt);
	} else {
		int i;
		for (i=0; i<7; i++)
			Geom.Value[i] = 0.0;
	}
	return Py_BuildValue("ffffffff", Q_new, Geom.Value[0],Geom.Value[1],Geom.Value[2],
						 Geom.Value[3],Geom.Value[4],Geom.Value[5],Geom.Value[6]);
}

struct SolarStruct CalcSolarFlux(int hour, int JD, double Altitude, double Zenith, double cloud,
								double d_w, double W_b, double Elevation, double TopoFactor, double ViewToSky,
								double SampleDist, double phi, int emergent, double VDensity, double VHeight,
								PyObject *ShaderList)
{

	PyObject *item0 = PySequence_GetItem(ShaderList,0);
	PyObject *item1 = PySequence_GetItem(ShaderList,1);
	PyObject *item2 = PySequence_GetItem(ShaderList,2);
	double FullSunAngle = PyFloat_AsDouble(item0);
	double TopoShadeAngle = PyFloat_AsDouble(item1);
	double BankShadeAngle = PyFloat_AsDouble(item2);
	Py_DECREF(item0);
	Py_DECREF(item1);
	Py_DECREF(item2);
	PyObject *RipExtinction = PySequence_GetItem(ShaderList,3); // 4 element tuple of extinction cooefficients by zone
	PyObject *VegetationAngle = PySequence_GetItem(ShaderList,4); // 4 element tuple of top-of-vegetation angles by zone

	double rip[4];
	double veg[4];
	int i;
	for (i=0; i<4; i++)
	{
		item0 = PySequence_GetItem(RipExtinction,i);
		item1 = PySequence_GetItem(VegetationAngle,i);
		rip[i] = PyFloat_AsDouble(item0);
		veg[i] = PyFloat_AsDouble(item1);
		Py_DECREF(item0);
		Py_DECREF(item1);
	}
	Py_DECREF(RipExtinction);
	Py_DECREF(VegetationAngle);
	// Constants
	float pi = 3.14159265358979323846f;
	float radians = pi/180.0;

	// Solar fluxes
	float direct_0 = 0.0;
	float direct_1 = 0.0;
	float direct_2 = 0.0;
	float direct_3 = 0.0;
	float direct_4 = 0.0;
	float direct_5 = 0.0;
	float direct_6 = 0.0;
	float direct_7 = 0.0;
	float diffuse_0 = 0.0;
	float diffuse_1 = 0.0;
	float diffuse_2 = 0.0;
	float diffuse_3 = 0.0;
	float diffuse_4 = 0.0;
	float diffuse_5 = 0.0;
	float diffuse_6 = 0.0;
	float diffuse_7 = 0.0;
    //#############################################################
    //Route solar radiation to the stream surface
    //   Flux_Solar(x) and Flux_Diffuse = Solar flux at various positions
    //       0 - Edge of atmosphere
    //       1 - Above Topography
    //       2 - Above Land Cover
    //       3 - Above Stream (After Land Cover Shade)
    //       4 - Above Stream (What a Solar Pathfinder Measures)
    //       5 - Entering Stream
    //       6 - Received by Water Column
    //       7 - Received by Bed
    //#######################################################
	//////////////////////////////////////////////////////////////////
	// 0 - Edge of atmosphere
	// TODO: Original VB code's JulianDay calculation:
	// JulianDay = -DateDiff("d", theTime, DateSerial(year(theTime), 1, 1))
	// THis calculation for Rad_Vec should be checked, with respect to the DST hour/24 part.
	float Rad_Vec = 1.0 + 0.017 * cos((2.0 * pi / 365.0) * (186.0 - JD + (float)hour / 24.0));
	float Solar_Constant = 1367.0; //W/m2
	direct_0 = (Solar_Constant / pow(Rad_Vec,2)) * sin(radians*(Altitude)); //Global Direct Solar Radiation
	///////////////////////////////////////////////////////////////////
    // 1 - Above Topography
    float Air_Mass = (35 / sqrt(1224 * sin(radians*Altitude) + 1)) * exp(-0.0001184 * Elevation);
    float Trans_Air = 0.0685 * cos((2 * pi / 365) * (JD + 10)) + 0.8;
    // Calculate Diffuse Fraction
	direct_1 = direct_0 * pow(Trans_Air,Air_Mass) * (1 - 0.65 * pow(cloud,2));
	float Clearness_Index;
    if (direct_0 == 0.0) { Clearness_Index = 1.0; }
    else {Clearness_Index = direct_1 / direct_0; }
    float Diffuse_Fraction = (0.938 + 1.071 * Clearness_Index) -
        (5.14 * pow(Clearness_Index,2)) +
        (2.98 * pow(Clearness_Index,3)) -
        (sin(2.0 * pi * (JD - 40.0) / 365.0)) *
        (0.009 - 0.078 * Clearness_Index);
    diffuse_1 = direct_1 * (Diffuse_Fraction) * (1 - 0.65 * pow(cloud,2));
    direct_1 *= (1 - Diffuse_Fraction);

    //########################################################
    //======================================================
    //2 - Above Land Cover
    // Empty
    //######################################################
    //======================================================
    //3 - Above Stream Surface (Above Bank Shade)
    if (Altitude <= TopoShadeAngle)	//>Topographic Shade IS Occurring<
    {
        direct_2 = 0;
        diffuse_2 = diffuse_1 * TopoFactor;
        direct_3 = 0;
        diffuse_3 = diffuse_2 * ViewToSky;
    }
    else if (Altitude < FullSunAngle) // #Partial shade from veg
    {
        direct_2 = direct_1;
        diffuse_2 = diffuse_1 * (1 - TopoFactor);
        float Dummy1 = direct_2;
        int i;
        for (i=0; i<4; i++)
        {
			if (Altitude < veg[i])
				Dummy1 *= (1.0-(1.0-exp(-1.0 * rip[i] * (SampleDist/cos(radians*Altitude)))));
		}
        direct_3 = Dummy1;
        diffuse_3 = diffuse_2 * ViewToSky;
    }
    else //Full sun
    {
        direct_2 = direct_1;
        diffuse_2 = diffuse_1 * (1 - TopoFactor);
        direct_3 = direct_2;
        diffuse_3 = diffuse_2 * ViewToSky;
    }

    //4 - Above Stream Surface (What a Solar Pathfinder measures)
    //Account for bank shade
    if ((Altitude > TopoShadeAngle) && (Altitude <= BankShadeAngle))  //Bank shade is occurring
    {
        direct_4 = 0;
        diffuse_4 = diffuse_3;
    }
    else  //bank shade is not occurring
    {
        direct_4 = direct_3;
        diffuse_4 = diffuse_3;
    }

    //Account for emergent vegetation
    if (emergent==1)
    {
    	float ripExtinctEmergent, shadeDensityEmergent;
        float pathEmergent = VHeight / sin(radians*Altitude);
        if (pathEmergent > W_b)
		{
            pathEmergent = W_b;
		}
        if (VDensity == 1.0)
        {
            VDensity = 0.9999;
            ripExtinctEmergent = 1.0;
            shadeDensityEmergent = 1.0;
        }
        else if (VDensity == 0.0)
        {
            VDensity = 0.00001;
            ripExtinctEmergent = 0.0;
            shadeDensityEmergent = 0.0;
        }
        else
        {
            ripExtinctEmergent = -log(1.0 - VDensity) / 10.0;
            shadeDensityEmergent = 1.0 - exp(-ripExtinctEmergent * pathEmergent);
        }
        direct_4 = direct_4 * (1.0 - shadeDensityEmergent);
		if (VHeight > 0.0)
		{
	        pathEmergent = VHeight;
    	    ripExtinctEmergent = -log(1.0 - VDensity) / VHeight;
        	shadeDensityEmergent = 1.0 - exp(-ripExtinctEmergent * pathEmergent);
        	diffuse_4 = diffuse_4 * (1.0 - shadeDensityEmergent);
		}
    }
    //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    //5 - Entering Stream
	float Stream_Reflect;
    if (Zenith > 80.0)
    {
        Stream_Reflect = 0.0515 * Zenith - 3.636;
    }
    else
    {
        Stream_Reflect = 0.091 * (1 / cos(Zenith * radians)) - 0.0386;
    }
    if (fabs(Stream_Reflect) > 1)
    {
        Stream_Reflect = 0.0515 * (Zenith * radians) - 3.636;
    }
    if (fabs(Stream_Reflect) > 1)
    {
        Stream_Reflect = 0.091 * (1 / cos(Zenith * pi / 180)) - 0.0386;
    }
    diffuse_5 = diffuse_4 * 0.91;
    direct_5 = direct_4 * (1 - Stream_Reflect);
    //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    //6 - Received by Water Column
	// Empty-
    //:::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    //7 - Received by Bed
    float Water_Path = d_w / cos(atan((sin(radians*Zenith) / 1.3333) / sqrt(-(sin(radians*Zenith) / 1.3333) * (sin(radians*Zenith) / 1.3333) + 1))); //Jerlov (1976)
    float Trans_Stream = 0.415 - (0.194 * log10(Water_Path * 100));
    if (Trans_Stream > 1)
    {
        Trans_Stream = 1;
    }
    float Dummy1 = direct_5 * (1 - Trans_Stream);       //Direct Solar Radiation attenuated on way down
    float Dummy2 = direct_5 - Dummy1 ;                  //Direct Solar Radiation Hitting Stream bed
    float Bed_Reflect = exp(0.0214 * (Zenith * radians) - 1.941);   //Reflection Coef. for Direct Solar
    float BedRock = 1 - phi;
    float Dummy3 = Dummy2 * (1 - Bed_Reflect);                //Direct Solar Radiation Absorbed in Bed
    float Dummy4 = 0.53 * BedRock * Dummy3;                  //Direct Solar Radiation Immediately Returned to Water Column as Heat
    float Dummy5 = Dummy2 * Bed_Reflect;                   //Direct Solar Radiation Reflected off Bed
    float Dummy6 = Dummy5 * (1 - Trans_Stream);              //Direct Solar Radiation attenuated on way up
    direct_6 = Dummy1 + Dummy4 + Dummy6;
    direct_7 = Dummy3 - Dummy4;
    Trans_Stream = 0.415 - (0.194 * log10(100 * d_w));
    if (Trans_Stream > 1)
    {
        Trans_Stream = 1;
    }
    Dummy1 = diffuse_5 * (1 - Trans_Stream);      //Diffuse Solar Radiation attenuated on way down
    Dummy2 = diffuse_5 - Dummy1;                  //Diffuse Solar Radiation Hitting Stream bed
    Bed_Reflect = exp(0.0214 * (0) - 1.941);               //Reflection Coef. for Diffuse Solar
    Dummy3 = Dummy2 * (1 - Bed_Reflect);                //Diffuse Solar Radiation Absorbed in Bed
    Dummy4 = 0.53 * BedRock * Dummy3;                   //Diffuse Solar Radiation Immediately Returned to Water Column as Heat
    Dummy5 = Dummy2 * Bed_Reflect;                      //Diffuse Solar Radiation Reflected off Bed
    Dummy6 = Dummy5 * (1 - Trans_Stream);               //Diffuse Solar Radiation attenuated on way up
    diffuse_6 = Dummy1 + Dummy4 + Dummy6;
    diffuse_7 = Dummy3 - Dummy4;

	struct SolarStruct Solar;
	Solar.Value[0] = diffuse_0 + direct_0;
	Solar.Value[1] = diffuse_1 + direct_1;
	Solar.Value[2] = diffuse_2 + direct_2;
	Solar.Value[3] = diffuse_3 + direct_3;
	Solar.Value[4] = diffuse_4 + direct_4;
	Solar.Value[5] = diffuse_5 + direct_5;
	Solar.Value[6] = diffuse_6 + direct_6;
	Solar.Value[7] = diffuse_7 + direct_7;

	return Solar;
}

struct GroundStruct
CalcGroundFluxes(double Cloud, double Humidity, double T_air, double Wind, double Elevation,
				  double phi, double VHeight, double ViewToSky, double SedDepth, double dx, double dt,
				  double SedThermCond, double SedThermDiff, double T_alluv, double P_w,
				  double W_w, int emergent, int penman, double wind_a, double wind_b,
				  double calcevap, double T_prev, double T_sed, double Q_hyp, double F_Solar5, double F_Solar7)
{
	//#################################################################
	// Bed Conduction Flux
    //======================================================
    //Calculate the conduction flux between water column & substrate
	float SedRhoCp = SedThermCond / (SedThermDiff/10000);
	// Water variables
	float rhow = 1000;				// water density (kg/m3)
	float H2O_HeatCapacity = 4187;	// J/(kg *C)

    float F_Conduction = SedThermCond * (T_sed - T_prev) / (SedDepth / 2);
    //Calculate the conduction flux between deeper alluvium & substrate
	float Flux_Conduction_Alluvium = 0.0;

    if (T_alluv > 0)
    {
        Flux_Conduction_Alluvium = SedThermCond * (T_sed - T_alluv) / (SedDepth / 2);
    }
    //======================================================
    //Calculate the changes in temperature in the substrate conduction layer
    // Negative hyporheic flow is heat into sediment
    float F_hyp = Q_hyp * rhow *H2O_HeatCapacity * (T_sed - T_prev) / ( W_w * dx);
    //Temperature change in substrate from solar exposure and conducted heat
    float NetFlux_Sed = F_Solar7 - F_Conduction - Flux_Conduction_Alluvium - F_hyp;
    float DT_Sed = NetFlux_Sed * dt / (SedDepth * SedRhoCp);
    //======================================================
    //Calculate the temperature of the substrate conduction layer
    float T_sed_new = T_sed + DT_Sed;
    if ((T_sed_new > 50.0f) || (T_sed_new < 0.0f))
	  	PyErr_SetString(HeatSourceError, "Sediment temperature not bounded in 0<=temp<=50.");
    // End Conduction Flux
	//###########################################################################################
	//##############################################################################
	// Longwave Flux
    float Sat_Vapor_Air = 6.1275 * exp(17.27 * T_air / (237.3 + T_air)); //mbar (Chapra p. 567)
    float Air_Vapor_Air = Humidity * Sat_Vapor_Air;
    float Sigma = 5.67e-8; //Stefan-Boltzmann constant (W/m2 K4)
    float Emissivity = 1.72 * pow(((Air_Vapor_Air * 0.1) / (273.2 + T_air)),(1.0/7.0)) * (1 + 0.22 * pow(Cloud,2.0)); //Dingman p 282
    //======================================================
    //Calcualte the atmospheric longwave flux
    float F_LW_Atm = 0.96 * ViewToSky * Emissivity * Sigma * pow((T_air + 273.2),4.0);
    //Calcualte the backradiation longwave flux
    float F_LW_Stream = -0.96 * Sigma * pow((T_prev + 273.2),4.0);
    //Calcualte the vegetation longwave flux
    float F_LW_Veg = 0.96 * (1 - ViewToSky) * 0.96 * Sigma * pow((T_air + 273.2),4);
	float F_Longwave = F_LW_Atm + F_LW_Stream + F_LW_Veg;
	//###############################################################################
	//######################################################################
	// Evaporative and Convective flux
	float F_evap, F_conv;
    float Pressure = 1013.0 - 0.1055 * Elevation; //mbar
    float Sat_Vapor = 6.1275 * exp(17.27 * T_prev / (237.3 + T_prev)); //mbar (Chapra p. 567)
    float Air_Vapor = Humidity * Sat_Vapor;
    //===================================================
    //Calculate the frictional reduction in wind velocity
    float Zd, Zo, Zm, Friction_Velocity;
    if ((emergent) && (VHeight > 0))
    {
        Zd = 0.7 * VHeight;
        Zo = 0.1 * VHeight;
        Zm = 2;
        Friction_Velocity = Wind * 0.4 / log((Zm - Zd) / Zo); //Vertical Wind Decay Rate (Dingman p. 594)
    } else {
        Zo = 0.00023; //Brustsaert (1982) p. 277 Dingman
        Zd = 0.0; //Brustsaert (1982) p. 277 Dingman
        Zm = 2.0;
        Friction_Velocity = Wind;
    }
    //===================================================
    //Wind Function f(w)
    float Wind_Function = wind_a + wind_b * Friction_Velocity; //m/mbar/s
    //===================================================
    //Latent Heat of Vaporization
    float LHV = 1000.0 * (2501.4 + (1.83 * T_prev)); //J/kg
    //===================================================
    //Use Jobson Wind Function
    float Bowen, K_evap;
    if (penman)
    {
        //Calculate Evaporation FLUX
        float P = 998.2; // kg/m3
        float Gamma = 1003.5 * Pressure / (LHV * 0.62198); //mb/*C  Cuenca p 141
        float Delta = 6.1275 * exp(17.27 * T_air / (237.3 + T_air)) - 6.1275 * exp(17.27 * (T_air - 1.0) / (237.3 + T_air - 1));
        float NetRadiation = F_Solar5 + F_Longwave;  //J/m2/s
        if (NetRadiation < 0.0)
        {
            NetRadiation = 0; //J/m2/s
        }
        float Ea = Wind_Function * (Sat_Vapor - Air_Vapor);  //m/s
        K_evap = ((NetRadiation * Delta / (P * LHV)) + Ea * Gamma) / (Delta + Gamma);
        F_evap = -K_evap * LHV * P; //W/m2
        //Calculate Convection FLUX
        Bowen = Gamma * (T_prev - T_air) / (Sat_Vapor - Air_Vapor);
    } else {
        //===================================================
        //Calculate Evaporation FLUX
        K_evap = Wind_Function * (Sat_Vapor - Air_Vapor);  //m/s
        float P = 998.2; // kg/m3
        F_evap = -K_evap * LHV * P; //W/m2
        //Calculate Convection FLUX
        if ((Sat_Vapor - Air_Vapor) != 0)
        {
            Bowen = 0.61 * (Pressure / 1000) * (T_prev - T_air) / (Sat_Vapor - Air_Vapor);
        } else {
            Bowen = 1.0;
        }
    }
    F_conv = F_evap * Bowen;
    float R_evap = 0.0;
    if (calcevap)
		R_evap = K_evap * W_w;
	// End Evap and Conv Flux
	//##############################################################################################
	struct GroundStruct Ground;
	Ground.Value[0] = F_Conduction;
	Ground.Value[1] = T_sed_new;
	Ground.Value[2] = F_Longwave;
	Ground.Value[3] = F_LW_Atm;
	Ground.Value[4] = F_LW_Stream;
	Ground.Value[5] = F_LW_Veg;
	Ground.Value[6] = F_evap;
	Ground.Value[7] = F_conv;
	Ground.Value[8] = R_evap;
	return Ground;
}

PyObject *
MacCormick(double dt, double dx, double U, double T_sed, double T_prev, double Q_hyp,
		   PyObject *Q_tup, PyObject *T_tup, double Q_up, double Delta_T, double Disp, int S1,
		   double S1_value, double T0, double T1, double T2, double Q_accr, double T_accr)
{
	double T_up = T0;
	double Temp=0;
	double Q_in = 0.0;
	double T_in = 0.0;
	int i;
	double numerator = 0.0;
	PyObject *Qitem, *Titem;
	int size = PyTuple_Size(Q_tup);

	if (size > 0)
	{
		for (i=0; i<size; i++)
		{
			Qitem = PySequence_GetItem(Q_tup, i);
			Titem = PySequence_GetItem(T_tup, i);
			if ((Qitem == NULL) || (Titem == NULL))
				PyErr_SetString(HeatSourceError, "Null value in the tributary discharge or temperature");
			if ((PyFloat_Check(Qitem)) && (PyFloat_Check(Titem)) && (PyFloat_AsDouble(Qitem) > 0))
			{
				Q_in += PyFloat_AsDouble(Qitem);
				numerator += PyFloat_AsDouble(Qitem)*PyFloat_AsDouble(Titem);
			}
			Py_DECREF(Qitem);
			Py_DECREF(Titem);
		}
		if ((numerator > 0) && (Q_in > 0))
			T_in = numerator/Q_in;
	}
    // This is basically MixItUp from the VB code
    double T_mix = ((Q_in * T_in) + (T_up * Q_up)) / (Q_up + Q_in);
    //Calculate temperature change from mass transfer from hyporheic zone
    T_mix = ((T_sed * Q_hyp) + (T_mix * (Q_up + Q_in))) / (Q_hyp + Q_up + Q_in);
    //Calculate temperature change from accretion inflows
    // Q_hyp is commented out because we are not currently sure if it should be added to the flow. This
    // is because adding it will cause overestimation of the discharge if Q_hyp is not subtracted from
    // the total discharge (Q_in) somewhere else, which it is not. We should check this eventually.
    T_mix = ((Q_accr * T_accr) + (T_mix * (Q_up + Q_in + Q_hyp))) / (Q_accr + Q_up + Q_in + Q_hyp);
	T_mix -= T_up;
	T0 += T_mix;

    float Dummy1 = -U * (T1 - T0) / dx;
    float Dummy2 = Disp * (T2 - 2 * T1 + T0) / pow(dx,2);
    float S = Dummy1 + Dummy2 + Delta_T / dt;
	if (S1 > 0)
	{
		Temp = T_prev + ((S1_value + S) / 2) * dt;
	} else {
		Temp = T1 + S * dt;
	}

	return Py_BuildValue("ff",Temp, S);
}

char *StrCat(char *str1, char *str2)
{
	char *str3;
	// TODO: make sure this is not a memory leak in Windows
	str3 = (char *)malloc((strlen(str1) + strlen(str2) + 1) * sizeof(char));
	strcpy(str3, str1);
	strcat(str3, str2);
	return str3;
}
void GetSetError(char *message, char *attr)
{
	char *err = "Error in C module! ";
	char *msg = StrCat(err, StrCat(message, attr));
	PyErr_SetString(HeatSourceError, msg);
}

double GetStringDouble(PyObject *obj, char * str)
{
	PyObject *PyFloat = PyObject_GetAttr( obj, PyString_FromString(str));
	if (!PyFloat_Check(PyFloat))
	{
		GetSetError("Error getting attribute: ", str);
		Py_DECREF(PyFloat);
	}
	double val = PyFloat_AsDouble(PyFloat);
	Py_XDECREF(PyFloat);
	return val;
}
int GetStringInt(PyObject *obj, char * str)
{
	PyObject *PyInt = PyObject_GetAttr( obj, PyString_FromString(str));
	if (!PyInt_Check(PyInt))
	{
		GetSetError("Error getting attribute: ", str);
		Py_DECREF(PyInt);
	}
	long val = PyInt_AsLong(PyInt);
	Py_XDECREF(PyInt);
	return (int)val;
}

double GetDictItemDouble(PyObject *obj, PyObject *key, char *name)
{
	PyObject *dict = PyObject_GetAttr(obj, PyString_FromString(name));
	if (!dict)
	{
		GetSetError((char *)"Error accessing dictionary: ", name);
		Py_DECREF(dict);
	}
	PyObject *value = PyDict_GetItem(dict, key);
	if (!value)
	{
		char *A = StrCat((char *)"Error accessing attribute ", PyString_AsString(key));
		char *B = StrCat((char *)" in dictionary ", name);
		GetSetError((char *)" ", StrCat(A,B));
	}
	double val = PyFloat_AsDouble(value);
	Py_DECREF(dict);
	return val;
}

PyObject *GetDictItemObject(PyObject *obj, PyObject *key, char *name)
{
	PyObject *dict = PyObject_GetAttr(obj, PyString_FromString(name));
	if (!dict)
	{
		GetSetError((char *)"Error accessing dictionary: ", name);
		Py_DECREF(dict);
	}
	PyObject *value = PyDict_GetItem(dict, key);
	if (!value)
	{
		char *A = StrCat((char *)"Error accessing attribute ", PyString_AsString(key));
		char *B = StrCat((char *)" in dictionary ", name);
		GetSetError((char *)" ", StrCat(A,B));
	}
	// We increment the reference count here to give ownership to the calling function
	Py_INCREF(value);
	return value;
}

void SetStringDouble(PyObject *obj, char *str, double val)
{
	PyObject *v = PyFloat_FromDouble(val);
	int ret = PyObject_SetAttrString(obj, str, v);
	if (ret < 0)
	{
		GetSetError((char *)"Error setting attribute: ", str);
		Py_DECREF(v);
	}
	Py_DECREF(v);
}

void SetStringInt(PyObject *obj, char *str, int val)
{
	PyObject *v = PyInt_FromLong(val);
	int ret = PyObject_SetAttrString(obj, str, v);
	if (ret < 0)
	{
		GetSetError((char *)"Error setting attribute: ", str);
		Py_DECREF(v);
	}
	Py_DECREF(v);
}

void SetStringObject(PyObject *obj, char *str, PyObject *Val)
{
	int ret = PyObject_SetAttrString(obj, str, Val);
	if (ret < 0)
		GetSetError((char *)"Error setting attribute: ", str);
}

static char heatsource_CalcMacCormick__doc__[] =
"Calculate central difference, first iteration"
;

static PyObject *
heatsource_CalcMacCormick(PyObject *self, PyObject *args)
{
	float dt, dx, U, T_sed, T_prev, Q_up;
	float Q_hyp, Q_accr, T_accr;
	float Delta_T, Disp, S1_value;
	int S1;
	PyObject *Q_tup, *T_tup;
	float T0, T1, T2; // Grid cells for prev, this, next
	if (!PyArg_ParseTuple(args, "ffffffOOfffiffffff", &dt, &dx, &U, &T_sed,
														  &T_prev, &Q_hyp, &Q_tup, &T_tup,
												 		  &Q_up, &Delta_T, &Disp, &S1,
												 		  &S1_value, &T0, &T1, &T2, &Q_accr, &T_accr))
		return NULL;
	PyObject *result = MacCormick(dt, dx, U, T_sed, T_prev, Q_hyp, Q_tup, T_tup,
									  Q_up, Delta_T, Disp, S1, S1_value, T0, T1, T2, Q_accr, T_accr);

	return Py_BuildValue("O",result);
}

static char heatsource_CalcFluxes__doc__[] =
"Calculate all of the fluxes"
;

static PyObject * heatsource_CalcFluxes(PyObject *self, PyObject *args)
{
	PyObject *ShaderList, *ContData, *C_args, *Q_tribs, *T_tribs;
	double W_b, Elevation, TopoFactor, ViewToSky, phi, VDensity, VHeight, SedDepth;
	double Altitude, Zenith, Q_up_prev, T_up_prev, T_dn_prev, Q_accr, T_accr, dx, dt;
	double SedThermCond, SedThermDiff, SampleDist, wind_a, wind_b, d_w, area, P_w, W_w;
	double U, T_alluv, T_prev, T_sed, Q_hyp, cloud, humidity, T_air, wind, Disp;
	int hour, JD, daytime, has_prev, emergent, calcevap, penman;
	if (!PyArg_ParseTuple(args, "OOdddddOOdddddOdiiidddd",
								&ContData, &C_args, &d_w, &area, &P_w, &W_w, &U,
								&Q_tribs, &T_tribs, &T_alluv, &T_prev, &T_sed, &Q_hyp,
								&T_dn_prev, &ShaderList, &Disp, &hour, &JD, &daytime,
								&Altitude, &Zenith, &Q_up_prev, &T_up_prev))
		return NULL;
	if (!PyArg_ParseTuple(ContData, "dddd", &cloud, &wind, &humidity, &T_air))
		return NULL;
	if (!PyArg_ParseTuple(C_args, "ddddddddddddddididdii",
								  &W_b, &Elevation, &TopoFactor, &ViewToSky, &phi, &VDensity, &VHeight,
								  &SedDepth, &dx, &dt, &SedThermCond, &SedThermDiff, &Q_accr, &T_accr,
								  &has_prev, &SampleDist, &emergent, &wind_a, &wind_b, &calcevap, &penman))
		return NULL;

	//###################################################################
	//## Calculate Solar Flux
	struct SolarStruct F_Solar;
	int i;
	for (i=0; i<8; i++) {F_Solar.Value[i] = 0.0;}
	if (daytime)
	{
		F_Solar = CalcSolarFlux(hour, JD, Altitude, Zenith, cloud,
							    d_w, W_b, Elevation, TopoFactor, ViewToSky,
							    SampleDist, phi, emergent, VDensity, VHeight, ShaderList);
	}
//	SetStringObject(node, (char *)"F_Solar", F_Solar);
	//####################################################################
	//## Calculate Ground Fluxes
	struct GroundStruct F_Ground = CalcGroundFluxes(cloud, humidity, T_air, wind, Elevation,
										  phi, VHeight, ViewToSky, SedDepth, dx, dt,
										  SedThermCond, SedThermDiff, T_alluv, P_w,
										  W_w, emergent, penman, wind_a, wind_b,
										  calcevap, T_prev, T_sed, Q_hyp, F_Solar.Value[5], F_Solar.Value[7]);
	// order: {F_Conduction,T_sed_new, F_Longwave, F_LW_Atm, F_LW_Stream, F_LW_Veg, F_evap, F_conv, R_evap}

	//#### Calculate and set total flux (With lots of error and reference checking!)
	double F_Total =  F_Solar.Value[6] + F_Ground.Value[0] + F_Ground.Value[2] + F_Ground.Value[6] + F_Ground.Value[7];
	//////////////////////////////////////////

	//#### Calculate and set delta T
	double Delta_T = F_Total * dt / ((area / W_w) * 4182 * 998.2); // Vars are Cp (J/kg *C) and P (kgS/m3)
	//##################################################################
	//## Calculate first MacCormick run
	T_sed = F_Ground.Value[1];
	if (!has_prev)
		return Py_BuildValue("(ffffffff)(fffffffff)ff", F_Solar.Value[0],F_Solar.Value[1],
						 F_Solar.Value[2],F_Solar.Value[3],F_Solar.Value[4],F_Solar.Value[5],
						 F_Solar.Value[6],F_Solar.Value[7],F_Ground.Value[0],F_Ground.Value[1],
						 F_Ground.Value[2],F_Ground.Value[3],F_Ground.Value[4],F_Ground.Value[5],
						 F_Ground.Value[6],F_Ground.Value[7],F_Ground.Value[8], F_Total, Delta_T);
	PyObject *MacC = MacCormick(dt, dx, U, T_sed, T_prev, Q_hyp, Q_tribs, T_tribs, Q_up_prev,
								Delta_T, Disp, 0, 0.0, T_up_prev, T_prev, T_dn_prev, Q_accr, T_accr);
	return Py_BuildValue("(ffffffff)(fffffffff)Off", F_Solar.Value[0],F_Solar.Value[1],
						 F_Solar.Value[2],F_Solar.Value[3],F_Solar.Value[4],F_Solar.Value[5],
						 F_Solar.Value[6],F_Solar.Value[7],F_Ground.Value[0],F_Ground.Value[1],
						 F_Ground.Value[2],F_Ground.Value[3],F_Ground.Value[4],F_Ground.Value[5],
						 F_Ground.Value[6],F_Ground.Value[7],F_Ground.Value[8], MacC, F_Total, Delta_T);
/*
	return Py_BuildValue("fff",0.0,0.0,0.0);
*/
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* List of methods defined in the module */

static struct PyMethodDef heatsource_methods[] = {
	{"CalcSolarPosition", (PyCFunction) heatsource_CalcSolarPosition, METH_VARARGS,  heatsource_CalcSolarPosition__doc__},
	{"CalcFluxes", (PyCFunction) heatsource_CalcFluxes, METH_VARARGS, heatsource_CalcFluxes__doc__},
	{"CalcFlows", (PyCFunction) heatsource_CalcFlows, METH_VARARGS, heatsource_CalcFlows__doc__},
	{"CalcMacCormick", (PyCFunction) heatsource_CalcMacCormick, METH_VARARGS,  heatsource_CalcMacCormick__doc__},
	{NULL,	 (PyCFunction)NULL, 0, NULL}		/* sentinel */
};


/* Initialization function for the module (*must* be called initheatsource) */

static char heatsource_module_documentation[] =
""
;

PyMODINIT_FUNC
initheatsource()
{
	PyObject *m, *d;

	/* Create the module and add the functions */
	m = Py_InitModule4("heatsource", heatsource_methods,
		heatsource_module_documentation,
		(PyObject*)NULL,PYTHON_API_VERSION);

	/* Add some symbolic constants to the module */
	d = PyModule_GetDict(m);
	HeatSourceError = PyString_FromString("HeatSourceError");
	Py_INCREF(HeatSourceError);
	PyDict_SetItemString(d, "HeatSourceError", HeatSourceError);

	/* XXXX Add constants here */
	PyDict_SetItemString(d, "__file__", PyString_FromString("heatsource.py"));
	PyDict_SetItemString(d, "__name__", PyString_FromString("heatsource"));


	/* Check for errors */
	if (PyErr_Occurred())
		Py_FatalError("can't initialize module heatsource");
}

