/* Generated by py2cmod
 *
 * py2cmod (c) 2001 Mark Rowe
 */

#include "Python.h"
#include <math.h>
#include <stdlib.h>

static PyObject *ErrorObject;

/* ----------------------------------------------------- */

static char heatsource_CalcSolarPosition__doc__[] =
"Calculates relative position of sun"
;

static PyObject *
heatsource_CalcSolarPosition(PyObject *self, PyObject *args)
{
	float lat;
	float lon;
	float hour;
	float min;
	float sec;
	float offset;
	float JDC;
	float Dummy; float Dummy1; float Dummy2; float Dummy3; float Dummy4; float Dummy5;
	/* temporary values calculated */
	float MeanObliquity; /* Average obliquity (degrees) */
	float Obliquity; /* Corrected obliquity (degrees) */
    float Eccentricity; /* Eccentricity of earth's orbit (unitless) */
    float GeoMeanLongSun; /*Geometric mean of the longitude of the sun*/
	float GeoMeanAnomalySun; /* Geometric mean of anomaly of the sun */
    float SunEqofCenter; /* Equation of the center of the sun (degrees)*/
    float SunApparentLong; /*Apparent longitude of the sun (degrees) */
    float Declination; /*Solar declination (degrees)*/
	float SunRadVector; /*    #Distance to the sun in AU */
	float Et; /* Equation of time (minutes)*/
	float SolarTime; /*Solar Time (minutes)*/
	float HourAngle;
	float Zenith; /*Solar Zenith Corrected for Refraction (degrees)*/
	float Azimuth; /* Solar azimuth in degrees */
	float Altitude; /*Solar Altitude Corrected for Refraction (degrees)*/
	float RefractionCorrection;
	float AtmElevation;
	float pi = 3.1415926535897931;
	float toRadians = pi/180.0;
	float toDegrees = 180.0/pi;


	if (!PyArg_ParseTuple(args, "fffffff", &lat, &lon, &hour, &min, &sec, &offset, &JDC))
		return NULL;

    MeanObliquity = 23.0 + (26.0 + ((21.448 - JDC * (46.815 + JDC * (0.00059 - JDC * 0.001813))) / 60.0)) / 60.0;
    Obliquity = MeanObliquity + 0.00256 * cos(toRadians*((125.04 - 1934.136 * JDC)));
    Eccentricity = 0.016708634 - JDC * (0.000042037 + 0.0000001267 * JDC);
    GeoMeanLongSun = 280.46646 + JDC * (36000.76983 + 0.0003032 * JDC);

    while (GeoMeanLongSun < 0) { GeoMeanLongSun += 360; }
   	while (GeoMeanLongSun > 360) { GeoMeanLongSun -= 360; }
    GeoMeanAnomalySun = 357.52911 + JDC * (35999.05029 - 0.0001537 * JDC);

    Dummy1 = toRadians*(GeoMeanAnomalySun);
    Dummy2 = sin(Dummy1);
    Dummy3 = sin(Dummy2 * 2);
    Dummy4 = sin(Dummy3 * 3);
    SunEqofCenter = Dummy2 * (1.914602 - JDC * (0.004817 + 0.000014 * JDC)) + Dummy3 * (0.019993 - 0.000101 * JDC) + Dummy4 * 0.000289;
    SunApparentLong = (GeoMeanLongSun + SunEqofCenter) - 0.00569 - 0.00478 * sin(toRadians*((125.04 - 1934.136 * JDC)));

    Dummy1 = sin(toRadians*Obliquity) * sin(toRadians*SunApparentLong);
    Declination = toDegrees*(atan(Dummy1 / sqrt(-Dummy1 * Dummy1 + 1)));

    SunRadVector = (1.000001018 * (1 - pow(Eccentricity,2))) / (1 + Eccentricity * cos(toRadians*(GeoMeanAnomalySun + SunEqofCenter)));

    /*#======================================================
    #Equation of time (minutes)*/
    Dummy = pow((tan(Obliquity * pi / 360)),2);
    Dummy1 = sin(toRadians*(2 * GeoMeanLongSun));
    Dummy2 = sin(toRadians*(GeoMeanAnomalySun));
    Dummy3 = cos(toRadians*(2 * GeoMeanLongSun));
    Dummy4 = sin(toRadians*(4 * GeoMeanLongSun));
    Dummy5 = sin(toRadians*(2 * GeoMeanAnomalySun));
    Et = toDegrees*(4 * (Dummy * Dummy1 - 2 * Eccentricity * Dummy2 + 4 * Eccentricity * Dummy * Dummy2 * Dummy3 - 0.5 * pow(Dummy,2) * Dummy4 - 1.25 * pow(Eccentricity,2) * Dummy5));

    SolarTime = (hour*60.0) + min + (sec/60.0) + (Et - 4.0 * -lon + (offset*60.0));

    while (SolarTime > 1440) { SolarTime -= 1440;}
    HourAngle = SolarTime / 4 - 180;
    if (HourAngle < -180) { HourAngle += 360;}

    Dummy = sin(toRadians*lat) * sin(toRadians*Declination) + cos(toRadians*lat) * cos(toRadians*Declination) * cos(toRadians*HourAngle);
    if (Dummy > 1) { Dummy = 1; }
    else if (Dummy < -1) { Dummy = -1; }

    Zenith = toDegrees*(acos(Dummy));
    Dummy = cos(toRadians*lat) * sin(toRadians*Zenith);
    if (abs(Dummy) > 0.001)
    {
        Azimuth = (sin(toRadians*lat) * cos(toRadians*Zenith) - sin(toRadians*Declination)) / Dummy;
    }
		return Py_BuildValue("ffffff",Azimuth,lat,Zenith,Declination,Dummy,toRadians);

/*
        if (abs(Azimuth) > 1)
        {
            if (Azimuth < 0) { Azimuth = -1; }
            else { Azimuth = 1; }
        }
        Azimuth = 180 - toDegrees*(acos(Azimuth));
        if (HourAngle > 0) { Azimuth *= -1; }
    } else
    {
        if (lat > 0) { Azimuth = 180; }
        else { Azimuth = 0; }
    }
    if (Azimuth < 0) { Azimuth += 360; }

    AtmElevation = 90 - Zenith;
    if (AtmElevation > 85) { RefractionCorrection = 0;}
    else
    {
        Dummy = tan(toRadians*(AtmElevation));
        if (AtmElevation > 5) {RefractionCorrection = 58.1 / Dummy - 0.07 / pow(Dummy,3) + 0.000086 / pow(Dummy,5); }
        else if (AtmElevation > -0.575) { RefractionCorrection = 1735 + AtmElevation * (-518.2 + AtmElevation * (103.4 + AtmElevation * (-12.79 + AtmElevation * 0.711)));}
        else { RefractionCorrection = -20.774 / Dummy; }
        RefractionCorrection = RefractionCorrection / 3600;
    }
    Zenith = Zenith - RefractionCorrection;
    Altitude = 90 - Zenith;

	return Py_BuildValue("fff",Azimuth,Altitude,Zenith);
*/}
static char heatsource_NewtonRaphsonSecant__doc__[] =
"Copy of the method used in the HeatSource VB code"
;

static PyObject *
heatsource_NewtonRaphsonSecant(PyObject *self, PyObject *args)
{
	float Q_est;
	float W_b;
	float z;
	float n;
	float S;
    float Converge = 10.0;
    float dy = 0.01;
    int count = 0;
	float D_est = 10;
	float Fy;
	float Fyy;
	float dFy;
	float thed;
	if (!PyArg_ParseTuple(args, "fffff", &Q_est, &W_b, &z, &n, &S))
		return NULL;

    while (Converge > 1e-8)
	{
        Fy = (D_est * (W_b + z * D_est)) * pow((D_est * (W_b + z * D_est))/ (W_b + 2 * D_est * sqrt(1+ pow(z,2))),(2/3)) - (n * Q_est) / sqrt(S);
        thed = D_est + dy;
        Fyy = (thed * (W_b + z * thed)) * pow((thed * (W_b + z * thed))/ (W_b + 2 * thed * sqrt(1+ pow(z,2))),(2/3)) - (n * Q_est) / sqrt(S);
        dFy = (Fyy - Fy) / dy;
        if (dFy <= 0) {dFy = 0.99;}
        thed = D_est - Fy / dFy;
        D_est = thed;
        if ((D_est < 0) || (D_est > 5000) || (count > 10000))
        {
        	D_est = (float)rand();
        	Converge = 0;
        	count = 0;
        }
        Converge = abs(Fy/dFy);
        count += 1;
	}
    return Py_BuildValue("f",D_est);
}
/* List of methods defined in the module */

static struct PyMethodDef heatsource_methods[] = {
	{"CalcSolarPosition", (PyCFunction) heatsource_CalcSolarPosition, METH_VARARGS,  heatsource_CalcSolarPosition__doc__},
		{"NewtonRaphsonSecant", (PyCFunction) heatsource_NewtonRaphsonSecant, METH_VARARGS,  heatsource_NewtonRaphsonSecant__doc__},

	{NULL,	 (PyCFunction)NULL, 0, NULL}		/* sentinel */
};


/* Initialization function for the module (*must* be called initheatsource) */

static char heatsource_module_documentation[] =
""
;

void
initheatsource()
{
	PyObject *m, *d;

	/* Create the module and add the functions */
	m = Py_InitModule4("heatsource", heatsource_methods,
		heatsource_module_documentation,
		(PyObject*)NULL,PYTHON_API_VERSION);

	/* Add some symbolic constants to the module */
	d = PyModule_GetDict(m);
	ErrorObject = PyString_FromString("heatsource.error");
	PyDict_SetItemString(d, "error", ErrorObject);

	/* XXXX Add constants here */
	PyDict_SetItemString(d, "__file__", PyString_FromString("heatsource.py"));
	PyDict_SetItemString(d, "__name__", PyString_FromString("heatsource"));


	/* Check for errors */
	if (PyErr_Occurred())
		Py_FatalError("can't initialize module heatsource");
}

